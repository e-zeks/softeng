from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QUrl
from PyQt5.QtGui import QDesktopServices
from PyQt5.QtWidgets import QHeaderView, QTableWidgetItem
from mysql.connector import Error

# Assuming Ui_MainWindow is defined in coachmanageclientUI.py
from screens.coachmanageclientUI import Ui_MainWindow

class CoachManageEmpWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    back_button = QtCore.pyqtSignal()
    logout_button = QtCore.pyqtSignal()
    edit_button = QtCore.pyqtSignal(dict)  # Signal to emit selected row data

    def __init__(self, conn):
        super(CoachManageEmpWindow, self).__init__()
        self.conn = conn
        self.log_ids = [] #
        self.setupUi(self)  # Assuming setupUi() is generated by Qt Designer
        self.client_details = {}

        self.logout.clicked.connect(self.handle_logout)
        self.back.clicked.connect(self.handle_back)
        self.edit.clicked.connect(self.handle_edit)
        self.help.clicked.connect(self.handle_help)
        self.search_bar.textChanged.connect(self.search_table)

        self.tableWidget.setSelectionBehavior(QtWidgets.QTableView.SelectRows)
        self.tableWidget.itemSelectionChanged.connect(self.handle_row_selection)

        self.refresh_data()  # Load data initially

    def handle_help(self):
        pdf_path = "C:\\Users\\JC\\Desktop\\softeng-main\\Anytime Fitness User Manual.pdf"
        QDesktopServices.openUrl(QUrl.fromLocalFile(pdf_path))


    def refresh_data(self):
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT * FROM coach_clients")
            results = cursor.fetchall()
            column_names = [i[0] for i in cursor.description]
            cursor.close()

            self.tableWidget.setColumnCount(len(column_names))
            self.tableWidget.setRowCount(len(results))
            self.tableWidget.setHorizontalHeaderLabels(column_names)

            for row_number, row_data in enumerate(results):
                for column_number, data in enumerate(row_data):
                    item = QTableWidgetItem(str(data))
                    self.tableWidget.setItem(row_number, column_number, item)

            self.tableWidget.resizeColumnsToContents()
            self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        except Error as e:
            print(f"Error loading data from database: {e}")

    def search_table(self):
        search_text = self.search_bar.text().strip().lower()
        for row in range(self.tableWidget.rowCount()):
            row_visible = False
            for column in range(self.tableWidget.columnCount()):
                item = self.tableWidget.item(row, column)
                if item and search_text in item.text().lower():
                    row_visible = True
                    break
            self.tableWidget.setRowHidden(row, not row_visible)

    def handle_row_selection(self):
        selected_items = self.tableWidget.selectedItems()
        if selected_items:
            row = selected_items[0].row()
            column_names = ["Client_Name", "Client_ID", "Email", "Completed_Sessions", "Cancelled_Sessions", "Package", "Initial_Weight", "Current_Weight"]
            client_details = {}
            for column_name in column_names:
                item = self.tableWidget.item(row, column_names.index(column_name))
                if item:
                    client_details[column_name] = item.text()

            self.client_details = client_details

    def handle_edit(self):
        print(f"Selected Row Data: {self.client_details}")
        self.edit_button.emit(self.client_details)

    def handle_back(self):
        self.back_button.emit()

    def log_user_logout(self):
        cursor = self.conn.cursor()
        print(f"Logging out users with LogIDs: {self.log_ids}")  # Debug print

        sql = " SELECT COUNT(*) FROM user_logs"
        cursor.execute(sql)
        lastrow = cursor.fetchone()[0]
        print(lastrow)
        if not self.log_ids:
            print("No log IDs to log out")  # Debug print
        try:
            print("ttest")
            # this gets the last row and adds date
            query = """
                       UPDATE user_logs
                       SET Logout_Time = NOW()
                       WHERE LogID = %s AND Logout_Time IS NULL
                   """
            cursor.execute(query, (lastrow,))
            self.conn.commit()
            print("Logout times updated successfully")  # Debug print
        except Error as e:
            print(f"Error logging user logout: {e}")
        finally:
            cursor.close()
            self.log_ids.clear()  # Clear the list of LogIDs after logging out

    def handle_logout(self):
        self.log_user_logout()
        self.logout_button.emit()